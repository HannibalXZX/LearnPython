
## 前言
除了有强调自学能力，其实在这个过程中李笑来还有两位得力帮手
@霍炬 @

不否认李笑来的自学编程能力，但指导自学，我个人觉得还是很难的。

先不断培养自学能力，然后建立资源。

基础这东西，看多少遍都不嫌多的。


## 关于程序

从定义上来看，所谓**程序**（Programs）其实一点都不神秘。

因为程序这个东西，不过是按照一定*顺序*完成任务的**流程**（Procedures）。根据定义，日常生活中你做盘蛋炒饭给自己吃，也是完成了一个 “做蛋炒饭” 的程序 —— 你按部就班完成了一系列的步骤，最终做好了一碗蛋炒饭给自己吃 —— 从这个角度望过去，所有的菜谱都是程序……

只不过，菜谱这种程序，编写者是人，执行者还是人；而我们即将要学会写的程序，编写者是人，执行者是计算机 —— 当然，菜谱用自然语言编写，计算机程序由程序员用编程语言编写。

然而，这些都不是最重要的差异 —— 最重要的差异在于计算机能做**布尔运算**（Boolean Operations）。

于是，一旦代码编写好之后，计算机在执行的过程中，除了可以 “*按照顺序执行任务*” 之外，还可以 “*根据不同情况执行不同的任务*”，比如，“*如果条件尚未满足则重复执行某一任务*”。

计算器和计算机都是电子设备，但计算机更为强大的原因，用通俗的说法就是它 “**可编程**”（Programable）—— 而所谓可编程的核心就是*布尔运算*及其相应的**流程控制**（Control Flow）；没有布尔运算能力就没有办法做*流程控制*；没有流程控制就只能 “按顺序执行”，那就显得 “很不智能”……

## 逻辑操作符
Python 语言中的**逻辑操作符**（Logical Operators）如下表所示 —— 为了理解方便，也可以将其称为 “*比较操作符*”。

| 比较操作符 | 意义     | 示例             | 布尔值  |
| ---------- | -------- | ---------------- | ------- |
| `==`       | 等于     | `1 == 2`         | `False` |
| `!=`       | 不等于   | `1 != 2`         | `True`  |
| `>`        | 大于     | `1 > 2`          | `False` |
| `>=`       | 大于等于 | `1 >= 1`         | `True`  |
| `<`        | 小于     | `1 < 2`          | `True`  |
| `<=`       | 小于等于 | `1 <= 2`         | `True`  |
| `in`       | 属于     | `'a' in 'basic'` | `True`  |

除了等于、大于、小于之外，Python 还有一个逻辑操作符，`in`：

这个表达式 `'a' in 'basic'` 用自然语言描述就是：

> “`'a'` 存在于 `'basic'` 这个字符串之中吗？”（属于关系）

## 操作符
在本节，我们见到的比较操作符可以比较它左右的值，而后返回一个布尔值。

我们也见过两个整数被**操作符** `%` 连接，左侧作为被除数，右侧作为除数，`11 % 3` 这个表达式的值是 `2`。对于数字，我们可用的操作符有 `+`、`-`、`*`、`/`、`//`、`%`、`**` —— 它们分别代表加、减、乘、除、商、余、幂。

```
print(11 / 3)    
3.6666666666666665
print(11 // 3) 
3
print(11%3)
2

```
## 流程控制
有了布尔运算能力之后，才有*根据情况决定流程*的所谓**流程控制**（Control Flow）的能力。

## 值
从本质上看，程序里的绝大多数语句包含着**运算**（Evaluation），即，在对某个值进行**评价**。这里的 “评价”，不是 “判断某人某事的好坏”，而是 “*计算出某个值究竟是什么*” —— 所以，我们用中文的 “**运算**” 翻译这个 “_Evaluation_” 可能表达得更准确一些。

在程序中，被运算的可分为**常量**（Literals）和**变量**（Variables）。

```
a = 1 + 2 * 3
a += 1
print(a)
```

在以上代码中，

`1`、`2`、`3`，都是**常量**。_Literal_ 的意思是“字面的”，顾名思义，常量的*值*就是它字面上的值。`1` 的值，就是 `1`。

`a` 是**变量**。顾名思义，它的值将来是可变的。比如，在第 2 句中，这个变量的*值*发生了改变，之前是 `7`，之后变成了 `8`。

第 1 句中的 `+`、`*`，是**操作符**（Operators），它用来对其左右的值进行相应的*运算*而后得到一个值。先是由操作符 `*` 对 `2` 和 `3` 进行运算，
生成一个值，`6`；然后再由操作符 `+` 对 `1` 和 `6` 进行运算，生成一个值 `7`。先算乘除后算加减，这是操作符的**优先级**决定的。

`=` 是赋值符号，它的作用是将它右边的值保存到左边的变量中。

在 Python 中每个函数都有*返回值*，即便你在定义一个函数的时候没有设定返回值，它也会加上默认的返回值 `None`……（请注意 `None` 的大小写！

## 值

### 语句块

在 Python 语言中，**行首空白**（Leading whitespace，由空格 `' '` 或者 Tab `⇥` 构成）有着特殊的含义。
python中整体代码格式如下图：
![](../the-craft-of-selfteaching-master/images/python-leading-space.png)
在同一个文件里，不建议混合使用 Tab 和 Space；要么全用空格，要么全用制表符。

### 值的类型
在编程语言中，总是包含最基本的三种数据类型：

> * 布尔值（Boolean Value)
> * 数字（Numbers）：整数（Int）、浮点数（Float）、复数（Complex Numbers）
> * 字符串（Strings）

既然有不同类型的数据，它们就分别对应着不同类型的值。
运算的一个默认法则就是，通常情况下应该是*相同类型的值才能相互运算*。

```
type(3)  # int
type(3.0) # float
type('3.14') # str
type(True) # bool
type(range(10)) # range
type([1,2,3]) # list
type((1,2,3)) # tuple
type({1,2,3}) # set
type({'a':1, 'b':2, 'c':3}) # dict
```

### 布尔值操作符
针对布尔值，操作符有`与`、`或`、`非`：`and`、`or`、`not`。

它们之中，优先级最低的是或 `or`，然后是与 `and`, 优先级最高的是非 `not`：

```
True and False or not True 
```
`False`

最先操作的是 `not`，因为它优先级最高。所以，上面的表达式相当于 `True and False or (not True)`，即相当于 `True and False or False`；

然后是 `and`，所以，`True and False or False` 相当于是 `(True and False) or False`，即相当于 `False or False`；

于是，最终的值是 `False`。

### 操作符优先级
数值之间还可以使用逻辑操作符，1 > 2 返回布尔值 False。逻辑操作符有：<（小于）、<=（小于等于）、>（大于）、>=（大于等于）、!=（不等于）、==（等于）。

逻辑操作符的优先级，高于布尔值的操作符，低于数值计算的操作符。 即：数值计算的操作符优先级最高，其次是逻辑操作符，布尔值的操作符优先级最低。
```
n = -95
n < 0 and (n + 1) % 2 == 0
```
`True`

### 字符串比较
这是因为字符对应着 Unicode 码，字符在被比较的时候，被比较的是对应的 Unicode 码。

```
'A' > 'a' # False
ord('A') # 65
ord('a') # 97
```
当字符串被比较的时候，将从两个字符串各自的第一个字符开始逐个比较，“一旦决出胜负马上停止”：
```
'PYTHON' > 'Python 3'
```
### 布尔值为False
> Here are most of the built-in objects considered `False`:
> 
> > * constants defined to be false: `None` and `False`.
> > * zero of any numeric type: `0`, `0.0`, `0j`, `Decimal(0)`, `Fraction(0, 1)`
> > * empty sequences and collections: `''`, `()`, `[]`, `{}`, `set()`, `range(0)`

### Continue、Break
`continue` 语句将忽略其后的语句开始下次循环，而 `break` 语句将从此结束当前循环，开始执行循环之后的语句：

![](../the-craft-of-selfteaching-master/images/continue-break.png)

### 控制流结构
有控制流，才能算得上是程序。

> * 只处理一种情况，用 `if ... `
> * 处理 `True`/`False` 两种情况，用 `if ... else ...`
> * 处理多种情况，用 `if ... elif ... elif ... else ...`
> * 迭代有序数据类型，用 `for ... in ...`，如果需要处理没有 `break` 发生的情况，用 `for ... else ...`
> * 其它循环，用 `while ...`
> * 与循环相关的语句还有 `continue`、`break`、`pass`
> * 函数从控制流角度去看其实就是子程序


## 函数
函数，实际上是可被调用的完整的程序。它具备输入、处理、输出的功能。又因为它经常在主程序里被调用，所以它总是更像是个子程序。

在我们使用函数的过程中，我们常常*有意忽略*它的内部如何完成从输入到输出之间的*处理过程* —— 这就好像我们平日里用灯泡一样，大多数情况下，我们只要知道开关的使用方法就够了 —— 至于为什么按到这个方向上灯会亮，为什么按到另外一个方向上灯会灭，并不是我们作为用户必须关心的事情。

### 关键字参数
在 Python 中，函数的参数，有两种：
> * **位置参数**（Positional Arguments，在官方文档里常被缩写为 *arg*）
> * **关键字参数**（Keyword Arguments，在官方文档里常被缩写为 *kwarg*）

在函数定义中，带有 `=` 的，即，已为其设定了默认值的参数，叫做 Keyword Arguments，其它的是 Positional Arguments。

在调用有 Keyword Arguments 的函数之时，如若不提供这些参数，那么参数在执行时，启用的是它在定义的时候为那些 Keyword Arguments 所设定的默认值；如若提供了这些参数的值，那么参数在执行的时候，启用的是接收到的相应值。

比如，`sorted()` 函数，它的定义如下：

> `sorted(iterable, *, key=None, reverse=False)`

现在先只关注它的 Keyword Arguments，`reverse`：

### 位置参数
位置参数，顾名思义，是 “由位置决定其值的参数”。

![](../the-craft-of-selfteaching-master/images/doc-divmod.png)

作为 “这个函数的用户”，你不能（事实上也没必要）调换这两个参数的意义。因为，根据定义，被传递的值的意义就是由参数的位置决定的。

它接收且必须接收两个参数。

> * 当你调用这个函数的时候，括号里写的第一个参数，是被除数，第二个参数是除数 —— 此为该函数的输入；
> * 而它的返回值，是一个元组（Tuple，至于这是什么东西，后面讲清楚），其中包括两个值，第一个是商，第二个是余 —— 此为该函数的输出。

作为 “这个函数的用户”，你不能（事实上也没必要）调换这两个参数的意义。因为，根据定义，被传递的值的意义就是由参数的位置决定的。

### 可选位置参数

有些函数，如 `pow()`，有**可选的位置参数**（Optional Positional Arguments）。

![](../the-craft-of-selfteaching-master/images/doc-pow.png)

于是，`pow()` 有两种用法，各有不同的结果：

> * `pow(x, y)` —— 返回值是 `x ** y`
> * `pow(x, y, z)` —— 返回值是 `x ** y % z`

```
pow(2, 3)
# pow(2, 3, 4)
```

![](../the-craft-of-selfteaching-master/images/doc-exec.png)

这些方括号的意思是说：

> * 没在方括号里的 `object` 是不可或缺的参数，调用时必须提供；
> * 可以有第二个参数，第二个参数会被接收为 `globals`；
> * 在有第二个参数的情况下，第三个参数会被接收为 `locals`；
> * *但是，你没办法在不指定 `globals` 这个位置参数的情况下指定 `locals`……*
### 小结
|名称  | 操作               | 结果                                                       | 官方文档链接                                           |
| --- | ----------------- | ------------------------------------------------------------| ------------------------------------------------------------ |
| 加  | `1 + 2`           | 3                                          |                                                              |
| 减  | `2 - 1`           | 1                                    |                                                              |
| 乘  | `3 * 5`           | 15                                       |                                                              |
| 除  | `6 / 2`           | 3.0                                      |                                                              |
| 商  | `7 // 3`          | 2                              |                                                              |
| 余  | `7 % 3`           | 1                              |                                                              |
| 负  | `-6`              | -6                             |                                                              |
| 正  | `+6`              | 6                              |                                                              |
| 绝对值 | `abs(-1)`         | 1                           | [`abs()`](https://docs.python.org/3/library/functions.html#abs) |
| 转换为整数| `int(3.14)`       | 3                        | [`int()`](https://docs.python.org/3/library/functions.html#int) |
| 转换为浮点数 | `float(3)`        | 3.0                   | [`float()`](https://docs.python.org/3/library/functions.html#float) |
| 商余 | `divmod(7, 3)`    | 2, 1                         | [`divmod()`](https://docs.python.org/3/library/functions.html#divmod) |
| 幂 | `pow(2, 10)`      | 1024                          | [`pow()`](https://docs.python.org/3/library/functions.html#pow) |
| 幂 | `3 ** 2`          | 9                             |                                                              |

## 5、字符串

### 精度
在计算机里，所有的东西最终都要被转换成数值。又由于计算机靠的是电路，所以，最终只能处理 `1` 和 `0`，于是，最基本的数值是二进制；于是，连整数、浮点数字，都要最终转换成二进制数值。这就是为什么在所有编程语言中 `1.1 + 2.2` 并不是你所想象的 `3.3` 的原因。

```
1.1 + 2.2
```

`3.3000000000000003`

### 字符码表
很久以前，计算机的中央处理器最多只能够处理 8 位二进制数值，所以，那时候的计算机只能处理 256 个字符，即，2<sup>8</sup> 个字符。那个时候计算机所使用的码表叫 ASCII。现在计算机的中央处理器，大多是 64 位的，所以可以使用 2<sup>64</sup> 容量的码表，叫做 [Unicode](https://zh.wikipedia.org/wiki/Unicode)。随着多年的收集，2018 年 6 月 5 日公布的 `11.0.0` 版本已经包含了 13 万个字符 —— 突破 10 万字符是在 2005 年<a href='#fn1' name='fn1b'><sup>[1]</sup></a>。

把单个字符转换成码值的函数是 `ord()`，它只接收单个字符，否则会报错；它返回该字符的  unicode 编码。与 `ord()` 相对的函数是 `chr()`，它接收且只接收一个整数作为参数，而后返回相应的字符。`ord()` 接收多个字符的话会报错。

```
ord('a')
chr(122)
```

### 索引
字符串是由一系列的字符构成的。在 Python 当中，有一个容器（Container）的概念，这个概念前面提到过，后面还会深入讲解。现在需要知道的是，字符串是容器的一种；容器可分为两种，有序的和无序的 —— 字符串属于**有序容器**。

对于有序容器中的元素 —— 字符串就是字符的有序容器 —— 由于它们是有索引的，所以我们可以根据索引提取容器中的值，你可以把 `[]` 当作是有序容器的操作符之一，我们姑且将其称为 “*索引操作符*”。

字符串里的每个字符，对应着一个从 `0` 开始的索引。比较有趣的是，索引可以是负数。

> * `s[index]` —— 返回索引值为 `index` 的那个字符
> * `s[start:]` —— 返回从索引值为 `start` 开始一直到字符串末尾的所有字符
> * `s[start:stop]` —— 返回从索引值为 `start` 开始一直到索引值为 `stop` 的那个字符*之前*的所有字符
> * `s[:stop]` —— 返回从字符串开头一直到索引值为 `stop` 的那个字符*之前*的所有字符
> * `s[start:stop:step]` —— 返回从索引值为 `start` 开始一直到索引值为 `stop` 的那个字符*之前*的，以 `step` 为步长提取的所有字符

提醒：无论是 `range(1,2)`，或者 `random.randrange(100, 1000)` 又或者 `s[start:stop]` 都有一个相似的规律，包含左侧的 `1`, `100`, `start`，不包含右侧的 `2`, `1000`, `stop`。

### 搜索和替换

让我们从 `str.count()` 这个搜寻子字符串出现次数的 Method（即，`str` 这个 `Class` 中定义的函数）开始。

官方文档是这么写的：

> `str.count(sub[,start[,end]])`

下面的函数说明加了默认值，以便初次阅读更容易理解：

> `str.count(sub [,start=0[, end=len(str)]])`

这里的方括号 `[]` 表示该参数可选；方括号里再次嵌套了一个方括号，这个意思是说，在这个可选参数 `start` 出现的情况下，还可以再有一个可选参数 `end`；

而 `=` 表示该参数有个默认值。上述这段说明如果你感到熟悉的话，说明前面的内容确实阅读到位了…… 与大量 “前置引用” 相伴随的是知识点的重复出现。

> * 只给定 `sub` 一个参数的话，于是从第一个字符开始搜索到字符串结束；
> * 如果，随后给定了一个可选参数的话，那么它是 `start`，于是从 `start` 开始，搜索到字符串结束；
> * 如果 `start` 之后还有参数的话，那么它是 `end`；于是从 `start` 开始，搜索到 `end - 1` 结束（即不包含索引值为 `end` 的那个字符）。
> 
> 返回值为字符串中 `sub` 出现的次数。

注意：字符串中第一个字符的索引值是 `0`。

```
s = """Simple is better than complex.
Complex is better than complicated."""
s.lower().count('mp') # 4
s.lower().count('mp', 10) # 3
s.lower().count('mp', 10, 30) # 1
```

### 去除子字符
`str.strip([chars])`
它最常用的场景是去除一个字符串首尾的所有空白，包括空格、TAB、换行符等等。

还可以只对左侧处理，`str.lstrip()` 或者只对右侧处理，`str.rstrip()`

```
s = "Simple is better than complex."
s.lstrip('pSix.mle')  # ' is better than complex.'
# 首部的 p 被处理了…… 参数中的字符顺序对结果没有影响，换成 Sipx.mle 也一样……
```

### 拆分字符串
`str.splitlines()` 返回的是个列表（List）—— 这又是一个前面曾简要提起过，但会在后面的章节才能详细讲解的概念 —— 由被拆分的每一行作为其中的元素。

`str.split()`, 是将一个字符串，根据分隔符进行拆分：

 `str.split(sep=None, maxsplit=-1)`

第二个参数指定拆分几次，0 次，即不拆分，默认值是 -1，拆分全部

### 字符串排版
将字符串居中放置 —— 前提是设定整行的长度
`str.center(width[, fillchar])`
注意，第 2 个参数可选，表示设定整行的宽度，且只接收单个字符 —— `char` 是 _character_ 的缩写。

第二个参数的值要比字符串大也才有效果，这个函数用来打印注释挺好。
```
s = 'Sparse is better than dense!'
s.title().center(60)
s.title().center(60, '=')
```

`'================Sparse Is Better Than Dense!================'`

### 字符串属性
'1234567890'.isalnum(): True
'abcdefghij'.isalpha(): True
'山巅一寺一壶酒'.isascii(): False
'0.123456789'.isdecimal(): False
'0.123456789'.isdigit(): False
'0.123456789'.isnumeric(): False
'Continue'.islower(): False
'Simple Is Better Than Complex'.isupper(): False
'Simple Is Better Than Complex'.istitle(): True
'	'.isprintable(): False
'	'.isspace(): True
'for'.isidentifier(): True

### 图片总结

若是自己动手整理成一个表格，总结归纳一下这一章节的内容，你就会发现其实没多繁杂，总之就还是那点事，

![](../the-craft-of-selfteaching-master/images/string-concepts.png)

## 容器
在 Python 中，有个数据容器（Container）的概念。

其中包括字符串、由 range() 函数生成的等差数列、列表（List）、元组（Tuple）、集合（Set）、字典（Dictionary）。

这些容器，各有各的用处。其中又分为可变容器（Mutable）和不可变容器（Immutable）。可变的有列表、集合、字典；不可变的有字符串、range() 生成的等差数列、元组。集合，又分为 Set 和 Frozen Set；其中，Set 是可变的，Frozen Set 是不可变的。

字符串、由 range() 函数生成的等差数列、列表、元组是有序类型（Sequence Type），而集合与字典是无序的。

![](images/python-containers-final.png)

### 迭代
数据容器里的元素是可以被迭代的（Iterable），它们其中包含的元素，可以被逐个访问，以便被处理。

对于数据容器，有一个操作符，in，用来判断某个元素是否属于某个容器。

由于数据容器的可迭代性，再加上这个操作符 in，在 Python 语言里写循环格外容易且方便（以字符串这个字符的容器作为例子）：